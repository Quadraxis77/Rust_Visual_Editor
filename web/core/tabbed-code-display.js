/**
 * Tabbed Code Display Component
 * 
 * Provides a tabbed interface for displaying multiple code files
 * generated by the MultiFileGenerator.
 * 
 * Requirements: 14.1, 14.4
 */

class TabbedCodeDisplay {
    constructor(containerId) {
        /**
         * The container element ID
         * @type {string}
         */
        this.containerId = containerId;
        
        /**
         * The container element
         * @type {HTMLElement}
         */
        this.container = null;
        
        /**
         * Map of filename -> code content
         * @type {Map<string, string>}
         */
        this.files = new Map();
        
        /**
         * Currently active tab
         * @type {string|null}
         */
        this.activeTab = null;
        
        /**
         * Tab elements
         * @type {Map<string, HTMLElement>}
         */
        this.tabElements = new Map();
        
        /**
         * Content elements
         * @type {Map<string, HTMLElement>}
         */
        this.contentElements = new Map();
        
        this._initialize();
    }

    /**
     * Initialize the tabbed display
     * @private
     */
    _initialize() {
        this.container = document.getElementById(this.containerId);
        
        if (!this.container) {
            throw new Error(`Container element with ID '${this.containerId}' not found`);
        }
        
        // Clear container
        this.container.innerHTML = '';
        
        // Create tab bar
        this.tabBar = document.createElement('div');
        this.tabBar.className = 'code-tab-bar';
        this.container.appendChild(this.tabBar);
        
        // Create content area
        this.contentArea = document.createElement('div');
        this.contentArea.className = 'code-content-area';
        this.container.appendChild(this.contentArea);
    }

    /**
     * Update the display with new files
     * 
     * @param {Map<string, string>} files - Map of filename -> code content
     * 
     * @example
     * display.updateFiles(new Map([
     *   ['main.rs', 'fn main() { }'],
     *   ['shader.wgsl', '@compute fn main() { }']
     * ]));
     */
    updateFiles(files) {
        if (!files || !(files instanceof Map)) {
            throw new Error('Files must be a Map');
        }

        this.files = new Map(files);
        this._render();
    }

    /**
     * Switch to a specific tab
     * 
     * @param {string} filename - The filename/tab to switch to
     */
    switchToTab(filename) {
        if (!this.files.has(filename)) {
            console.warn(`File '${filename}' not found`);
            return;
        }

        // Deactivate current tab
        if (this.activeTab) {
            const oldTab = this.tabElements.get(this.activeTab);
            const oldContent = this.contentElements.get(this.activeTab);
            
            if (oldTab) oldTab.classList.remove('active');
            if (oldContent) oldContent.classList.remove('active');
        }
        
        // Activate new tab
        this.activeTab = filename;
        const newTab = this.tabElements.get(filename);
        const newContent = this.contentElements.get(filename);
        
        if (newTab) newTab.classList.add('active');
        if (newContent) newContent.classList.add('active');
    }

    /**
     * Get the currently active tab
     * 
     * @returns {string|null} The active filename, or null if none
     */
    getActiveTab() {
        return this.activeTab;
    }

    /**
     * Clear all tabs and content
     */
    clear() {
        this.files.clear();
        this.tabElements.clear();
        this.contentElements.clear();
        this.activeTab = null;
        
        if (this.tabBar) this.tabBar.innerHTML = '';
        if (this.contentArea) this.contentArea.innerHTML = '';
    }

    /**
     * Download a specific file
     * 
     * @param {string} filename - The filename to download
     */
    downloadFile(filename) {
        if (!this.files.has(filename)) {
            console.warn(`File '${filename}' not found`);
            return;
        }

        const content = this.files.get(filename);
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        
        URL.revokeObjectURL(url);
    }

    /**
     * Download all files as a ZIP
     * Requires JSZip library
     */
    async downloadAllAsZip() {
        if (typeof JSZip === 'undefined') {
            console.error('JSZip library is required for ZIP export');
            return;
        }

        const zip = new JSZip();
        
        // Add each file to the ZIP
        for (const [filename, content] of this.files.entries()) {
            zip.file(filename, content);
        }
        
        // Generate and download ZIP
        const blob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'blockly-project.zip';
        a.click();
        
        URL.revokeObjectURL(url);
    }

    // ========== PRIVATE METHODS ==========

    /**
     * Render the tabs and content
     * @private
     */
    _render() {
        // Clear existing tabs and content
        this.tabBar.innerHTML = '';
        this.contentArea.innerHTML = '';
        this.tabElements.clear();
        this.contentElements.clear();
        
        // If no files, show empty state
        if (this.files.size === 0) {
            this._renderEmptyState();
            return;
        }
        
        // Create tabs and content for each file
        let firstFile = null;
        
        for (const [filename, code] of this.files.entries()) {
            if (!firstFile) firstFile = filename;
            
            // Create tab
            const tab = this._createTab(filename);
            this.tabBar.appendChild(tab);
            this.tabElements.set(filename, tab);
            
            // Create content
            const content = this._createContent(filename, code);
            this.contentArea.appendChild(content);
            this.contentElements.set(filename, content);
        }
        
        // Activate first tab if no active tab
        if (!this.activeTab || !this.files.has(this.activeTab)) {
            this.switchToTab(firstFile);
        } else {
            this.switchToTab(this.activeTab);
        }
    }

    /**
     * Create a tab element
     * @private
     */
    _createTab(filename) {
        const tab = document.createElement('div');
        tab.className = 'code-tab';
        tab.textContent = filename;
        
        // Add click handler
        tab.addEventListener('click', () => {
            this.switchToTab(filename);
        });
        
        // Add download button
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'code-tab-download';
        downloadBtn.textContent = 'â†“';
        downloadBtn.title = `Download ${filename}`;
        downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.downloadFile(filename);
        });
        
        tab.appendChild(downloadBtn);
        
        return tab;
    }

    /**
     * Create a content element
     * @private
     */
    _createContent(filename, code) {
        const content = document.createElement('div');
        content.className = 'code-content';
        
        // Create code display
        const pre = document.createElement('pre');
        const codeElement = document.createElement('code');
        codeElement.textContent = code;
        
        // Add language class for syntax highlighting if available
        const lang = this._getLanguageFromFilename(filename);
        if (lang) {
            codeElement.className = `language-${lang}`;
        }
        
        pre.appendChild(codeElement);
        content.appendChild(pre);
        
        // Apply syntax highlighting if Prism is available
        if (typeof Prism !== 'undefined' && lang) {
            Prism.highlightElement(codeElement);
        }
        
        return content;
    }

    /**
     * Render empty state
     * @private
     */
    _renderEmptyState() {
        const emptyState = document.createElement('div');
        emptyState.className = 'code-empty-state';
        emptyState.innerHTML = `
            <p>No code generated yet.</p>
            <p>Add blocks to the workspace to generate code.</p>
        `;
        this.contentArea.appendChild(emptyState);
    }

    /**
     * Get language identifier from filename
     * @private
     */
    _getLanguageFromFilename(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        
        const langMap = {
            'rs': 'rust',
            'wgsl': 'wgsl',
            'js': 'javascript',
            'ts': 'typescript',
            'py': 'python',
            'cpp': 'cpp',
            'c': 'c',
            'java': 'java',
            'go': 'go',
            'json': 'json',
            'xml': 'xml',
            'html': 'html',
            'css': 'css'
        };
        
        return langMap[ext] || null;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TabbedCodeDisplay;
}
